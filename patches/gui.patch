Index: com/limegroup/gnutella/bugs/LocalClientInfo.java
===================================================================
RCS file: /cvs/gui/com/limegroup/gnutella/bugs/LocalClientInfo.java,v
retrieving revision 1.5
diff -u -r1.5 LocalClientInfo.java
--- com/limegroup/gnutella/bugs/LocalClientInfo.java	5 Nov 2003 23:37:57 -0000	1.5
+++ com/limegroup/gnutella/bugs/LocalClientInfo.java	5 Aug 2004 10:03:03 -0000
@@ -8,6 +8,7 @@
 import com.limegroup.gnutella.settings.Setting;
 import com.limegroup.gnutella.settings.FileSetting;
 import com.limegroup.gnutella.settings.FileArraySetting;
+import com.limegroup.gnutella.settings.PasswordSetting;
 import com.limegroup.gnutella.settings.LimeProps;
 
 import java.io.File;
@@ -76,6 +77,7 @@
 		        Setting set = (Setting)it.next();
 		        if( !(set instanceof FileSetting) &&
 		            !(set instanceof FileArraySetting) &&
+                    !(set instanceof PasswordSetting) &&
 		            !set.isDefault() )
 		            props.put(set.getKey(), set.getValueAsString());
             }
Index: com/limegroup/gnutella/gui/Initializer.java
===================================================================
RCS file: /cvs/gui/com/limegroup/gnutella/gui/Initializer.java,v
retrieving revision 1.130
diff -u -r1.130 Initializer.java
--- com/limegroup/gnutella/gui/Initializer.java	26 Jul 2004 18:52:09 -0000	1.130
+++ com/limegroup/gnutella/gui/Initializer.java	5 Aug 2004 10:03:04 -0000
@@ -4,6 +4,8 @@
 import com.limegroup.gnutella.bugs.BugManager;
 import com.limegroup.gnutella.browser.ExternalControl;
 import com.limegroup.gnutella.settings.StartupSettings;
+import com.limegroup.gnutella.settings.DaapSettings;
+import com.limegroup.gnutella.gui.DaapManager;
 import com.limegroup.gnutella.util.SystemUtils;
 import com.limegroup.gnutella.util.CommonUtils;
 import com.limegroup.gnutella.util.I18NConvert;
@@ -78,19 +80,20 @@
         
         // Set the messaging handler so we can receive core messages
         com.limegroup.gnutella.MessageService.setCallback(new MessageHandler());
-
-        // Set the message resource handler so we can internationalize strings
-        com.limegroup.gnutella.MessageResourceService.setCallback(new MessageResourceHandler());
-
+        
         // Set the default event error handler so we can receive uncaught
         // AWT errors.
-        DefaultErrorCatcher.install();
+        if(!CommonUtils.isJava118())
+            DefaultErrorCatcher.install();
         
         // Register MacOS X specific stuff.
         if (CommonUtils.isMacOSX()) {
             LOG.trace("START registering OSX events");
             // Register GURL to receive AppleEvents, such as magnet links.
             GURLHandler.getInstance().register();
+            // Register Cocoa handlers for the menus.
+            if(CommonUtils.isJava14OrLater())
+                CocoaApplicationEventHandler.instance().register();
             // Raise the number of allowed concurrent open files to 1024.
             SystemUtils.setOpenFileLimit(1024);
             LOG.trace("STOP registering OSX events");
@@ -252,13 +255,30 @@
         // Activate a download for magnet URL locally if one exists
         ExternalControl.runQueuedMagnetRequest();
         
+        // Start DaapManager if Java 1.4 or later and DAAP support
+        // is enabled
+        if (CommonUtils.isJava14OrLater() && 
+                DaapSettings.DAAP_ENABLED.getValue()) {
+            
+            LOG.trace("START DaapManager");
+            try {
+                GUIMediator.setSplashScreenString(
+                        GUIMediator.getStringResource("SLPASH_STATUS_DAAP"));
+                DaapManager.instance().start();
+                DaapManager.instance().init();
+            } catch (java.io.IOException err) {
+                ErrorService.error(err);
+            }
+            LOG.trace("STOP DaapManager");
+        }
+        
         // Tell the GUI that loading is all done.
         GUIMediator.instance().loadFinished();
         
         // update the repaintInterval after the Splash is created,
         // so that the splash gets the smooth animation.
         if(CommonUtils.isMacOSX() && CommonUtils.isJava14OrLater())
-            UIManager.put("ProgressBar.repaintInterval", new Integer(500));    
+            UIManager.put("ProgressBar.repaintInterval", new Integer(500));
         
         if(LOG.isTraceEnabled()) {
             long stopMemory = Runtime.getRuntime().totalMemory()
Index: com/limegroup/gnutella/gui/VisualConnectionCallback.java
===================================================================
RCS file: /cvs/gui/com/limegroup/gnutella/gui/VisualConnectionCallback.java,v
retrieving revision 1.118
diff -u -r1.118 VisualConnectionCallback.java
--- com/limegroup/gnutella/gui/VisualConnectionCallback.java	4 Aug 2004 04:25:10 -0000	1.118
+++ com/limegroup/gnutella/gui/VisualConnectionCallback.java	5 Aug 2004 10:03:05 -0000
@@ -13,6 +13,8 @@
 import com.limegroup.gnutella.security.User;
 import com.limegroup.gnutella.update.gui.*;
 import com.limegroup.gnutella.search.*;
+import com.limegroup.gnutella.FileManagerEvent;
+import com.limegroup.gnutella.util.CommonUtils;
 
 /**
  * This class is the interface from the backend to the frontend.  It
@@ -201,31 +203,40 @@
          LIBRARY_MEDIATOR.updateSharedFile(file);
     }
         
-
-	public void clearSharedFiles() 
-	{
-	    SwingUtilities.invokeLater(new Runnable() {
-	        public void run() {
-	            try {
-		            LIBRARY_MEDIATOR.clearLibrary();
-		        } catch(Throwable e) {
-		            GUIMediator.showInternalError(e, "clearSharedFiles");
-		        }
-		    }
-		 });
-	}
-
-	public void setAnnotateEnabled(final boolean enabled) {
-		SwingUtilities.invokeLater(new Runnable() {
-			public void run() {
-				try {
-					LIBRARY_MEDIATOR.setAnnotateEnabled(enabled);
-				} catch(Throwable e) {
-					GUIMediator.showInternalError(e, "setAnnotateEnabled");
-				}
-			}
-		});
-	}
+    public void handleFileManagerEvent(FileManagerEvent evt) {
+        if (CommonUtils.isJava14OrLater()) {
+            DaapManager.instance().handleFileManagerEvent(evt);
+        }
+    }
+    
+    public void clearSharedFiles() 
+    {
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                try {
+    	            LIBRARY_MEDIATOR.clearLibrary();
+    	        } catch(Throwable e) {
+    	            GUIMediator.showInternalError(e, "clearSharedFiles");
+    	        }
+    	    }
+    	 });
+    }
+    
+    public void setAnnotateEnabled(final boolean enabled) {
+    	SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+            	try {
+        		    LIBRARY_MEDIATOR.setAnnotateEnabled(enabled);
+            	} catch(Throwable e) {
+        		    GUIMediator.showInternalError(e, "setAnnotateEnabled");
+            	}
+            }
+    	});
+        
+    	if (CommonUtils.isJava14OrLater()) {
+    	    DaapManager.instance().setAnnotateEnabled(enabled);
+    	}
+    }
 
 
     public void addDownload(Downloader mgr)
Index: com/limegroup/gnutella/gui/options/OptionsConstructor.java
===================================================================
RCS file: /cvs/gui/com/limegroup/gnutella/gui/options/OptionsConstructor.java,v
retrieving revision 1.64
diff -u -r1.64 OptionsConstructor.java
--- com/limegroup/gnutella/gui/options/OptionsConstructor.java	24 May 2004 22:14:16 -0000	1.64
+++ com/limegroup/gnutella/gui/options/OptionsConstructor.java	5 Aug 2004 10:03:06 -0000
@@ -71,8 +71,8 @@
 
 		// make the window non-resizable only for operating systems
 		// where we know this will not cause a problem
-		if( (CommonUtils.isWindows() && CommonUtils.isJava14OrLater()) ||
-		    CommonUtils.isMacClassic() || CommonUtils.isMacOSX()) {
+		if(CommonUtils.isWindows() || CommonUtils.isMacClassic() ||
+		   CommonUtils.isMacOSX()) {
 			DIALOG.setResizable(false);
 		}
 		DIALOG.setSize(OPTIONS_WIDTH, OPTIONS_HEIGHT);
@@ -125,6 +125,7 @@
 		final String CHAT_KEY           = "OPTIONS_CHAT_MAIN_TITLE";
 		final String PLAYER_KEY         = "OPTIONS_PLAYER_MAIN_TITLE";
         final String ITUNES_KEY			= "OPTIONS_ITUNES_MAIN_TITLE";
+        final String ITUNES_DAAP_KEY    = "OPTIONS_ITUNES_DAAP_MAIN_TITLE";
 		final String POPUPS_KEY         = "OPTIONS_POPUPS_MAIN_TITLE";
 		final String BUGS_KEY           = "OPTIONS_BUGS_MAIN_TITLE";
 		final String APPS_KEY           = "OPTIONS_APPS_MAIN_TITLE";
@@ -143,7 +144,6 @@
         final String AUTOCOMPLETE_KEY   = "OPTIONS_AUTOCOMPLETE_MAIN_TITLE"; 
         final String STARTUP_KEY        = "OPTIONS_STARTUP_MAIN_TITLE";   
         final String PROXY_KEY          = "OPTIONS_PROXY_MAIN_TITLE";
-        final String CONN_PREF_KEY      = "OPTIONS_CONNECT_PREF_MAIN_TITLE";
 
 		// Create all of the panes that can be displayed to the user.
 		// For each pane, create all of the corresponding pane items,
@@ -207,13 +207,28 @@
 			playerPane.add(new PlayerPreferencePaneItem("PLAYER_PREFERENCE"));
 			addOption(OptionsMediator.ROOT_NODE_KEY, playerPane);
 		}
+		
+        
+		if (CommonUtils.isJava14OrLater() || CommonUtils.isMacOSX()) {
+        
+                    addGroupTreeNode(OptionsMediator.ROOT_NODE_KEY, ITUNES_KEY);
 
-        if (CommonUtils.isMacOSX()) {
-            final OptionsPane playerPane2 = new OptionsPaneImpl(ITUNES_KEY);
-			playerPane2.add(new iTunesPreferencePaneItem("ITUNES_PREFERENCE"));
-			addOption(OptionsMediator.ROOT_NODE_KEY, playerPane2);
-        }
-
+                    // Auto import of newly downloaded files is only 
+                    // available on Mac OS X
+                    if (CommonUtils.isMacOSX()) {
+                        final OptionsPane itunesPane = new OptionsPaneImpl(ITUNES_KEY);
+                        itunesPane.add(new iTunesPreferencePaneItem("ITUNES_PREFERENCE"));
+                        addOption(ITUNES_KEY, itunesPane);
+                    }
+
+                    if (CommonUtils.isJava14OrLater()) {
+                        final OptionsPane daapPane = new OptionsPaneImpl(ITUNES_DAAP_KEY);
+                        daapPane.add(new DaapSupportPaneItem("ITUNES_DAAP_PREFERENCE"));
+                        daapPane.add(new DaapPasswordPaneItem("ITUNES_DAAP_PASSWORD"));
+                        addOption(ITUNES_KEY, daapPane);
+                    }
+                }
+        
 		if (CommonUtils.isUnix()) {
 			final OptionsPane browserPane = new OptionsPaneImpl(APPS_KEY);
 			browserPane.add(new BrowserPaneItem("BROWSER_PREFERENCE"));
@@ -294,11 +309,6 @@
 		proxyPane.add(new ProxyLoginPaneItem("PROXY_LOGIN"));
 		addOption(ADVANCED_KEY, proxyPane);
         
-        final OptionsPane localePrefPane = new OptionsPaneImpl(CONN_PREF_KEY);
-        localePrefPane.add
-            (new LocalePreferencingPaneItem("CONNECT_LOCALE_PREF"));
-        addOption(ADVANCED_KEY, localePrefPane);
-
         // we currently only support running LimeWire on system startup on
         // Windows systems where LimeWire was installed using InstallShield,
         // which this checks (more or less with the LANGUAGE setting)
Index: com/limegroup/gnutella/gui/DaapManager.java
===================================================================
RCS file: com/limegroup/gnutella/gui/DaapManager.java
diff -N com/limegroup/gnutella/gui/DaapManager.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ com/limegroup/gnutella/gui/DaapManager.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,888 @@
+package com.limegroup.gnutella.gui;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.BindException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Locale;
+
+import javax.jmdns.JmDNS;
+import javax.jmdns.ServiceInfo;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import com.limegroup.gnutella.FileDesc;
+import com.limegroup.gnutella.FileManagerEvent;
+import com.limegroup.gnutella.IncompleteFileDesc;
+import com.limegroup.gnutella.RouterService;
+import com.limegroup.gnutella.URN;
+import com.limegroup.gnutella.filters.IPFilter;
+import com.limegroup.gnutella.settings.DaapSettings;
+import com.limegroup.gnutella.util.CommonUtils;
+import com.limegroup.gnutella.util.FileUtils;
+import com.limegroup.gnutella.util.ManagedThread;
+import com.limegroup.gnutella.util.NetworkUtils;
+import com.limegroup.gnutella.xml.LimeXMLDocument;
+import com.limegroup.gnutella.xml.LimeXMLReplyCollection;
+import com.limegroup.gnutella.xml.SchemaReplyCollectionMapper;
+
+import de.kapsi.net.daap.DaapAuthenticator;
+import de.kapsi.net.daap.DaapConfig;
+import de.kapsi.net.daap.DaapFilter;
+import de.kapsi.net.daap.DaapServer;
+import de.kapsi.net.daap.DaapServerFactory;
+import de.kapsi.net.daap.DaapStreamSource;
+import de.kapsi.net.daap.DaapThreadFactory;
+import de.kapsi.net.daap.Transaction;
+import de.kapsi.net.daap.TransactionListener;
+import de.kapsi.net.daap.DaapUtil;
+import de.kapsi.net.daap.Database;
+import de.kapsi.net.daap.Library;
+import de.kapsi.net.daap.Playlist;
+import de.kapsi.net.daap.Song;
+
+/**
+ * This class handles the mDNS registration and acts as an
+ * interface between LimeWire and DAAP.
+ */
+public final class DaapManager implements FinalizeListener, TransactionListener {
+    
+    private static final Log LOG = LogFactory.getLog(DaapManager.class);
+    private static final DaapManager INSTANCE = new DaapManager();
+    
+    private static final String AUDIO_SCHEMA = "http://www.limewire.com/schemas/audio.xsd";
+    
+    public static DaapManager instance() {
+        return INSTANCE;
+    }
+
+    private SongURNMap map;
+    
+    private Library library;
+    private Database database;
+    private Playlist whatsNew;
+    private DaapServer server;
+    private RendezvousService rendezvous;
+    
+    private boolean annotateEnabled = false;
+    private int maxPlaylistSize;
+    
+    private DaapManager() {
+        if (CommonUtils.isJava14OrLater() == false)
+            throw new RuntimeException("Cannot instance DaapManager");
+        
+        GUIMediator.addFinalizeListener(this);
+    }
+    
+    /**
+     * Initializes the Library
+     */
+    public synchronized void init() {
+        
+        if (isServerRunning()) {
+            setAnnotateEnabled(annotateEnabled);
+        }
+    }
+    
+    /**
+     * Starts the DAAP Server
+     */
+    public synchronized void start() throws IOException {
+        
+        if (!isServerRunning()) {
+            
+            try {
+                
+                map = new SongURNMap();
+                
+                maxPlaylistSize = DaapSettings.DAAP_MAX_LIBRARY_SIZE.getValue();
+                
+                String name = DaapSettings.DAAP_LIBRARY_NAME.getValue();
+                int revisions = DaapSettings.DAAP_LIBRARY_REVISIONS.getValue();
+                boolean useLibraryGC = DaapSettings.DAAP_LIBRARY_GC.getValue();
+                library = new Library(name, revisions, useLibraryGC);
+                
+                database = new Database(name);
+                whatsNew = new Playlist(GUIMediator.getStringResource("SEARCH_TYPE_WHATSNEW"));
+                
+                Transaction txn = library.open(false);
+                library.add(txn, database);
+                database.add(txn, whatsNew);
+                whatsNew.setSmartPlaylist(txn, true);
+                txn.commit();
+                
+                LimeConfig config = new LimeConfig();
+                
+                final boolean NIO = DaapSettings.DAAP_USE_NIO.getValue();
+                server = DaapServerFactory.createServer(library, config, NIO);
+                server.setAuthenticator(new LimeAuthenticator());
+                server.setStreamSource(new LimeStreamSource());
+                server.setFilter(new LimeFilter());
+                
+                if (!NIO) {
+                    server.setThreadFactory(new LimeThreadFactory());
+                }
+                
+                final int maxAttempts = 10;
+                
+                for(int i = 0; i < maxAttempts; i++) {
+                    try {
+                        server.bind();
+                        break;
+                    } catch (BindException bindErr) {
+                        if (i < (maxAttempts-1)) {
+                            // try next port...
+                            config.nextPort();
+                        } else {
+                            throw bindErr;
+                        }
+                    }
+                }
+                
+                Thread serverThread = new ManagedThread(server, "DaapServerThread");
+                serverThread.setDaemon(true);
+                serverThread.start();
+                
+                rendezvous = new RendezvousService();
+                rendezvous.registerService();
+                
+            } catch (IOException err) {
+                stop();
+                throw err;
+            }
+        }
+    }
+    
+    /**
+     * Stops the DAAP Server and releases all resources
+     */
+    public synchronized void stop() {
+        
+        if (rendezvous != null)
+            rendezvous.close();
+        
+        if (server != null)
+            server.stop();
+        
+        if (map != null)
+            map.clear();
+        
+        rendezvous = null;
+        server = null;
+        map = null;
+        library = null;
+        whatsNew = null;
+        database = null;
+    }
+    
+    /**
+     * Restarts the DAAP server and re-registers it via mDNS.
+     * This is equivalent to:<p>
+     *
+     * <code>
+     * stop();
+     * start();
+     * init();
+     * </code>
+     */
+    public synchronized void restart() throws IOException {
+        if (isServerRunning())
+            stop();
+    
+        start();
+        init();
+    }
+    
+    /**
+     * Shutdown the DAAP service properly. In this case
+     * is the main focus on mDNS (Rendezvous) as in
+     * some rare cases iTunes doesn't recognize that
+     * LimeWire/DAAP is no longer online.
+     */
+    public void doFinalize() {
+        stop();
+    }
+    
+    /**
+     * Updates the multicast-DNS servive info
+     */
+    public synchronized void updateService() throws IOException {
+        
+        if (isServerRunning()) {
+            rendezvous.updateService();
+
+            Transaction txn = library.open(false);
+            String name = DaapSettings.DAAP_LIBRARY_NAME.getValue();
+            library.setName(txn, name);
+            database.setName(txn, name);
+            txn.commit();
+            server.update();
+        }
+    }
+    
+    /**
+     * Disconnects all clients
+     */
+    public synchronized void disconnectAll() {
+        if (isServerRunning()) {
+            server.disconnectAll();
+        }
+    }
+    
+    /**
+     * Returns <tt>true</tt> if server is running
+     */
+    public synchronized boolean isServerRunning() {
+        if (server != null) {
+            return server.isRunning();
+        }
+        return false;
+    }
+    
+    /**
+     * Returns true if the extension of name is a supported file type.
+     */
+    private static boolean isSupportedFormat(String name) {
+        String[] types = DaapSettings.DAAP_SUPPORTED_FILE_TYPES.getValue();
+        for(int i = 0; i < types.length; i++) {
+            if (name.endsWith(types[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Called by VisualConnectionCallback
+     */
+    public synchronized void handleFileManagerEvent(FileManagerEvent evt) {
+
+        if (!isServerRunning())
+            return;
+              
+        if (evt.isChangeEvent()) {
+            
+            FileDesc oldDesc = evt.getFileDesc()[0];
+            
+            Song song = map.remove(oldDesc.getSHA1Urn());
+            
+            if (song != null) {
+                
+                FileDesc newDesc = evt.getFileDesc()[1];
+                map.put(song, newDesc.getSHA1Urn());
+                String format = song.getFormat();
+                
+                // Any changes in the meta data?
+                if ( updateSongMeta(song, newDesc) ) {
+                    Transaction txn = library.open(true);
+                    txn.addTransactionListener(this);
+                    database.update(txn, song);
+                }
+            }
+            
+        } else if (evt.isAddEvent()) {
+            
+            if (database.getMasterPlaylist().size() >= maxPlaylistSize) {
+                
+                return;
+            }
+            
+            FileDesc file = evt.getFileDesc()[0];
+            
+            if (!(file instanceof IncompleteFileDesc)) {
+                String name = file.getName().toLowerCase(Locale.US);
+                if (isSupportedFormat(name)) {
+                    
+                    Song song = createSong(file);
+                    map.put(song, file.getSHA1Urn());
+                    
+                    Transaction txn = library.open(true);
+                    txn.addTransactionListener(this);
+                    database.add(txn, song);
+                }
+            }
+            
+        } else if (evt.isRenameEvent()) {
+            
+            FileDesc oldDesc = evt.getFileDesc()[0];
+            Song song = map.remove(oldDesc.getSHA1Urn());
+            
+            if (song != null) {
+                FileDesc newDesc = evt.getFileDesc()[1];
+                map.put(song, newDesc.getSHA1Urn());
+            }
+            
+        } else if (evt.isRemoveEvent()) {
+            
+            FileDesc file = evt.getFileDesc()[0];
+            Song song = map.remove(file.getSHA1Urn());
+            
+            if (song != null) {
+                Transaction txn = library.open(true);
+                txn.addTransactionListener(this);
+                database.remove(txn, song);
+            }
+        }
+    }
+    
+    /**
+     * Called by VisualConnectionCallback/MetaFileManager.
+     */
+    public synchronized void setAnnotateEnabled(boolean enabled) {
+        
+        this.annotateEnabled = enabled;
+        
+        if (!isServerRunning() || !enabled)
+            return;
+         
+        int size = database.getMasterPlaylist().size();
+        
+        Transaction txn = library.open(false);
+        
+        SongURNMap tmpMap = new SongURNMap();
+        
+        FileDesc[] files = RouterService.getFileManager().getAllSharedFileDescriptors();
+        
+        for(int i = 0; i < files.length; i++) {
+            
+            FileDesc file = files[i];
+            
+            if (!(file instanceof IncompleteFileDesc)) {
+                String name = file.getName().toLowerCase(Locale.US);
+                if (isSupportedFormat(name)) {
+                    
+                    URN urn = file.getSHA1Urn();
+                    
+                    // 1)
+                    // _Remove_ URN from the current 'map'...
+                    Song song = map.remove(urn);
+                        
+                    // Check if URN is already in the tmpMap.
+                    // If so do nothing as we don't want add 
+                    // the same file multible times...
+                    if (tmpMap.contains(urn) == false) {
+                        
+                        // This URN was already mapped with a Song.
+                        // Save the Song (again) and update the meta
+                        // data if necessary
+                        if (song != null) {
+                            
+                            tmpMap.put(song, urn);
+
+                            // Any changes in the meta data?
+                            if ( updateSongMeta(song, file) ) {
+                                database.update(txn, song);
+                            }
+
+                        } else if (size < maxPlaylistSize){
+                            
+                            // URN was unknown and we must create a
+                            // new Song for this URN...
+                            
+                            song = createSong(file);
+                            tmpMap.put(song, urn);
+                            database.getMasterPlaylist().add(txn, song);
+                            size++;
+                        }
+                    }
+                }
+            }
+        }
+        
+        // See 1)
+        // As all known URNs were removed from 'map' only
+        // deleted FileDesc URNs can be leftover! We must 
+        // remove the associated Songs from the Library now
+        Iterator it = map.getSongIterator();
+        while(it.hasNext()) {
+            Song song = (Song)it.next();
+            database.remove(txn, song);
+        }
+        
+        map.clear();
+        map = tmpMap; // tempMap is the new 'map'
+        
+        txn.addTransactionListener(this);
+        txn.commit();
+    }
+    
+    /**
+     * Create a Song and sets its meta data with
+     * the data which is retrieved from the FileDesc
+     */
+    private Song createSong(FileDesc desc) {
+        
+        Song song = new Song(desc.getName());
+        song.setSize((int)desc.getSize());
+        song.setDateAdded((int)(System.currentTimeMillis()/1000));
+        
+        File file = desc.getFile();
+        String ext = FileUtils.getFileExtension(file);
+        
+        if (ext != null) {
+            
+            // Note: This is required for formats other than MP3
+            // For example AAC (.m4a) files won't play if no
+            // format is set. As far as I can tell from the iTunes
+            // 'Get Info' dialog are Songs assumed as MP3 until
+            // a format is set explicit.
+            
+            song.setFormat(ext.toLowerCase(Locale.US));
+            
+            updateSongMeta(song, desc);
+        }
+        
+        return song;
+    }
+    
+    /**
+     * Sets the meta data
+     */
+    private boolean updateSongMeta(Song song, FileDesc desc) {
+        
+        SchemaReplyCollectionMapper map = SchemaReplyCollectionMapper.instance();
+        LimeXMLReplyCollection collection = map.getReplyCollection(AUDIO_SCHEMA);
+        
+        if (collection == null) {
+            LOG.error("LimeXMLReplyCollection is null");
+            return false;
+        }
+        
+        LimeXMLDocument doc = collection.getDocForHash(desc.getSHA1Urn());
+        
+        if (doc == null)
+            return false;
+        
+        boolean update = false;
+        
+        String title = doc.getValue("audios__audio__title__");
+        String track = doc.getValue("audios__audio__track__");
+        String artist = doc.getValue("audios__audio__artist__");
+        String album = doc.getValue("audios__audio__album__");
+        String genre = doc.getValue("audios__audio__genre__");
+        String bitrate = doc.getValue("audios__audio__bitrate__");
+        String comments = doc.getValue("audios__audio__comments__");
+        String time = doc.getValue("audios__audio__seconds__");
+        String year = doc.getValue("audios__audio__year__");
+        
+        if (title != null) {
+            String currentTitle = song.getName();
+            if (currentTitle == null || !title.equals(currentTitle)) {
+                update = true;
+                song.setName(title);
+            }
+        }
+        
+        int currentTrack = song.getTrackNumber();
+        if (track != null) {
+            try {
+                int num = Integer.parseInt(track);
+                if (num > 0 && num != currentTrack) {
+                    update = true;
+                    song.setTrackNumber(num);
+                }
+            } catch (NumberFormatException err) {}
+        } else if (currentTrack != 0) {
+            update = true;
+            song.setTrackNumber(0);
+        }
+        
+        String currentArtist = song.getArtist();
+        if (artist != null) {
+            if (currentArtist == null || !artist.equals(currentArtist)) {
+                update = true;
+                song.setArtist(artist);
+            }
+        } else if (currentArtist != null) {
+            update = true;
+            song.setArtist(null);
+        }
+        
+        String currentAlbum = song.getAlbum();
+        if (album != null) {
+            if (currentAlbum == null || !album.equals(currentAlbum)) {
+                update = true;
+                song.setAlbum(album);
+            }
+        } else if (currentAlbum != null) {
+            update = true;
+            song.setAlbum(null);
+        }
+        
+        String currentGenre = song.getGenre();
+        if (genre != null) {
+            if (currentGenre == null || !genre.equals(currentGenre)) {
+                update = true;
+                song.setGenre(genre);
+            }
+        } else if (currentGenre != null) {
+            update = true;
+            song.setGenre(null);
+        }
+        
+        String currentComments = song.getComment();
+        if (comments != null) {
+            if (currentComments == null || !comments.equals(currentComments)) {
+                update = true;
+                song.setComment(comments);
+            }
+        } else if (currentComments != null) {
+            update = true;
+            song.setComment(null);
+        }
+        
+        int currentBitrate = song.getBitrate();
+        if (bitrate != null) {
+            try {
+                int num = Integer.parseInt(bitrate);
+                if (num > 0 && num != currentBitrate) {
+                    update = true;
+                    song.setBitrate(num);
+                }
+            } catch (NumberFormatException err) {}
+        } else if (currentBitrate != 0) {
+            update = true;
+            song.setBitrate(0);
+        }
+        
+        int currentTime = song.getTime();
+        if (time != null) {
+            try {
+                // iTunes expects the song length in milliseconds
+                int num = (int)Integer.parseInt(time)*1000;
+                if (num > 0 && num != currentTime) {
+                    update = true;
+                    song.setTime(num);
+                }
+            } catch (NumberFormatException err) {}
+        } else if (currentTime != 0) {
+            update = true;
+            song.setTime(0);
+        }
+        
+        int currentYear = song.getYear();
+        if (year != null) {
+            try {
+                int num = Integer.parseInt(year);
+                if (num > 0 && num != currentYear) {
+                    update = true;
+                    song.setYear(num);
+                }
+            } catch (NumberFormatException err) {}
+        } else if (currentYear != 0) {
+            update = true;
+            song.setYear(0);
+        }
+        
+        // iTunes expects the date/time in seconds
+        int mod = (int)(desc.lastModified()/1000);
+        if (song.getDateModified() != mod) {
+            update = true;
+            song.setDateModified(mod);
+        }
+        
+        return update;
+    }
+    
+    public synchronized void commit(Transaction txn) {
+        if (isServerRunning()) {
+            server.update();
+        }
+    }
+    
+    public void rollback(Transaction txn) {
+    }
+    
+    /**
+     * This factory creates ManagedThreads for the DAAP server
+     */
+    private final class LimeThreadFactory implements DaapThreadFactory {
+               
+        public Thread createDaapThread(Runnable runner, String name) {
+            Thread thread = new ManagedThread(runner, name);
+            thread.setDaemon(true);
+            return thread;
+        }
+    }
+    
+    /**
+     * Handles the audio stream
+     */
+    private final class LimeStreamSource implements DaapStreamSource {
+        
+        public FileInputStream getSource(Song song) throws IOException {
+            URN urn = map.get(song);
+            
+            if (urn != null) {
+                FileDesc fileDesc = RouterService.getFileManager().getFileDescForUrn(urn);
+                
+                if (fileDesc != null) {
+                    File file = fileDesc.getFile();
+                    
+                    FileInputStream in = new FileInputStream(file);
+                    
+                    return in;
+                }
+            }
+            
+            return null;
+        }
+    }
+    
+    /**
+     * Implements the DaapAuthenticator
+     */
+    private final class LimeAuthenticator implements DaapAuthenticator {
+        
+        public boolean requiresAuthentication() {
+            return DaapSettings.DAAP_REQUIRES_PASSWORD.getValue();
+        }
+        
+        /**
+         * Returns true if username and password are correct.<p>
+         * Note: iTunes does not support usernames (i.e. it's
+         * don't care)!
+         */
+        public boolean authenticate(String username, String password) {
+            return password.equals(DaapSettings.DAAP_PASSWORD.getValue());
+        }
+    }
+    
+    /**
+     * The DAAP Library should be only accessable from the LAN
+     * as we can not guarantee for the required bandwidth and it
+     * could be used to bypass Gnutella etc. Note: iTunes can't
+     * connect to DAAP Libraries outside of the LAN but certain
+     * iTunes download tools can.
+     */
+    private final class LimeFilter implements DaapFilter {
+
+        /**
+         * Returns true if <tt>address</tt> is a private address
+         */
+        public boolean accept(InetAddress address) {
+            
+            try {
+                // Is address a private address?
+                if ( ! NetworkUtils.isPrivateAddress(address))
+                    return false;
+            } catch (IllegalArgumentException err) {
+                LOG.error(err);
+                return false;
+            }
+            
+            // Is it a annoying fellow? >:-)
+            return IPFilter.instance().allow(address.getAddress());
+        }
+    }
+    
+    /**
+     * A LimeWire specific implementation of DaapConfig
+     */
+    private final class LimeConfig implements DaapConfig {
+        
+        public LimeConfig() {
+            // Reset PORT to default value to prevent increasing
+            // it to infinity
+            DaapSettings.DAAP_PORT.revertToDefault();
+        }
+        
+        public String getServerName() {
+            return CommonUtils.getHttpServer();
+        }
+        
+        public void nextPort() {
+            int port = DaapSettings.DAAP_PORT.getValue();
+            DaapSettings.DAAP_PORT.setValue(port+1);
+        }
+        
+        public int getBacklog() {
+            return 0;
+        }
+        
+        public InetSocketAddress getInetSocketAddress() {
+            int port = DaapSettings.DAAP_PORT.getValue();
+            return new InetSocketAddress(port);
+        }
+        
+        public int getMaxConnections() {
+            return DaapSettings.DAAP_MAX_CONNECTIONS.getValue();
+        }
+    }
+    
+    /**
+     * Helps us to publicize and update the DAAP Service via
+     * multicast-DNS (aka Rendezvous or Zeroconf)
+     */
+    private final class RendezvousService {
+        
+        private static final String VERSION = "Version";
+        private static final String MACHINE_NAME = "Machine Name";
+        private static final String PASSWORD = "Password";
+        
+        private JmDNS zeroConf;
+        private ServiceInfo service;
+        
+        public RendezvousService() throws IOException {
+            zeroConf = new JmDNS();
+        }
+        
+        public boolean isRegistered() {
+            return (service != null);
+        }
+        
+        private ServiceInfo createServiceInfo() {
+            
+            String type = DaapSettings.DAAP_TYPE_NAME.getValue();
+            String name = DaapSettings.DAAP_SERVICE_NAME.getValue();
+            
+            int port = DaapSettings.DAAP_PORT.getValue();
+            int weight = DaapSettings.DAAP_WEIGHT.getValue();
+            int priority = DaapSettings.DAAP_PRIORITY.getValue();
+            
+            boolean password = DaapSettings.DAAP_REQUIRES_PASSWORD.getValue();
+            
+            java.util.Hashtable props = new java.util.Hashtable();
+            
+            // Greys the share and the playlist names when iTunes's
+            // protocol version is different from this version. It's
+            // only a nice visual effect and has no impact to the
+            // ability to connect this server! Disabled because 
+            // iTunes 4.2 is still widespread...
+            props.put(VERSION, Integer.toString(DaapUtil.VERSION_3));
+            
+            // This is the inital share name
+            props.put(MACHINE_NAME, name);
+            
+            // shows the small lock if Service is protected
+            // by a password!
+            props.put(PASSWORD, Boolean.toString(password)); 
+            
+            String qualifiedName = null;
+            
+            // This isn't really required but as iTunes
+            // does it in this way I'm doing it too...
+            if (password) {
+                qualifiedName = name + "_PW." + type;
+            } else {
+                qualifiedName = name + "." + type;
+            }
+            
+            ServiceInfo service = new ServiceInfo(type, qualifiedName, port, 
+                                                     weight, priority, props);
+            
+            return service;
+        }
+        
+        public void registerService() throws IOException {
+            
+            if (isRegistered())
+                throw new IOException();
+            
+            ServiceInfo service = createServiceInfo();
+            zeroConf.registerService(service);
+            this.service = service;
+        }
+        
+        public void unregisterService() {
+            if (!isRegistered())
+                return;
+            
+            zeroConf.unregisterService(service);
+            service = null;
+        }
+        
+        public void updateService() throws IOException {
+            if (!isRegistered())
+                throw new IOException();
+            
+            
+            if (service.getPort() != DaapSettings.DAAP_PORT.getValue())
+                unregisterService();
+            
+            ServiceInfo service = createServiceInfo();
+            zeroConf.registerService(service);
+            
+            this.service = service;
+        }
+        
+        public void close() {
+            unregisterService();
+            zeroConf.close();
+        }
+    }
+    
+    /**
+     * A simple wrapper for a two way mapping as we have to
+     * deal in both directions with FileManager and DaapServer
+     * <p>
+     * Song -> URN
+     * URN -> Song
+     */
+    private final class SongURNMap {
+        
+        private HashMap /* Song -> URN */ songToUrn = new HashMap();
+        private HashMap /* URN -> Song */ urnToSong = new HashMap();
+        
+        public SongURNMap() {
+        }
+        
+        public void put(Song song, URN urn) {
+            songToUrn.put(song, urn);
+            urnToSong.put(urn, song);
+        }
+        
+        public URN get(Song song) {
+            return (URN)songToUrn.get(song);
+        }
+        
+        public Song get(URN urn) {
+            return (Song)urnToSong.get(urn);
+        }
+        
+        public Song remove(URN urn) {
+            Song song = (Song)urnToSong.remove(urn);
+            if (song != null)
+                songToUrn.remove(song);
+            return song;
+        }
+        
+        public URN remove(Song song) {
+            URN urn = (URN)songToUrn.remove(song);
+            if (urn != null)
+                urnToSong.remove(urn);
+            return urn;
+        }
+        
+        public boolean contains(URN urn) {
+            return urnToSong.containsKey(urn);
+        }
+        
+        public boolean contains(Song song) {
+            return songToUrn.containsKey(song);
+        }
+        
+        public Iterator getSongIterator() {
+            return songToUrn.keySet().iterator();
+        }
+        
+        public Iterator getURNIterator() {
+            return urnToSong.keySet().iterator();
+        }
+        
+        public void clear() {
+            urnToSong.clear();
+            songToUrn.clear();
+        }
+        
+        public int size() {
+            // NOTE: songToUrn.size() == urnToSong.size()
+            return songToUrn.size();
+        }
+    }
+}
Index: com/limegroup/gnutella/gui/SizedPasswordField.java
===================================================================
RCS file: com/limegroup/gnutella/gui/SizedPasswordField.java
diff -N com/limegroup/gnutella/gui/SizedPasswordField.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ com/limegroup/gnutella/gui/SizedPasswordField.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,65 @@
+package com.limegroup.gnutella.gui;
+
+import javax.swing.JPasswordField;
+import java.awt.Dimension;
+
+/**
+ * This class creates a <tt>JPasswordField</tt> with a standardized size.<p>
+ *
+ * It sets the preffered and maximum size of the field to the standard
+ * <tt>Dimension</tt> or sets the preferred and maximum sizes to the
+ * <tt>Dimension</tt> argument.
+ */
+//2345678|012345678|012345678|012345678|012345678|012345678|012345678|012345678|
+public final class SizedPasswordField extends JPasswordField {
+	
+	/**
+	 * Constant for the standard <tt>Dimension</tt> for the 
+	 * <tt>JPasswordField</tt>.
+	 */
+	public static final Dimension STANDARD_DIMENSION = new Dimension(500, 20);
+
+	/**
+	 * Creates a <tt>JPasswordField</tt> with a standard size.
+	 */
+	public SizedPasswordField() {
+		setPreferredSize(STANDARD_DIMENSION);
+		setMaximumSize(STANDARD_DIMENSION);
+	}
+
+	/**
+	 * Creates a <tt>JPasswordField</tt> with a standard size and with the 
+	 * specified <tt>Dimension</tt>.
+	 *
+	 * @param dim the <tt>Dimension</tt> to size the field to
+	 */
+	public SizedPasswordField(final Dimension dim) {
+		setPreferredSize(dim);
+		setMaximumSize(dim);
+	}
+
+	/**
+	 * Creates a <tt>JPasswordField</tt> with a standard size and with the 
+	 * specified number of columns.
+	 *
+	 * @param columns the number of columns to use in the field
+	 */
+	public SizedPasswordField(final int columns) {
+		super(columns);
+		setPreferredSize(STANDARD_DIMENSION);
+		setMaximumSize(STANDARD_DIMENSION);
+	}
+
+	/**
+	 * Creates a <tt>JPasswordField</tt> with a standard size and with the 
+	 * specified number of columns and the specified <tt>Dimension</tt>..
+	 *
+	 * @param columns the number of columns to use in the field
+	 * @param dim the <tt>Dimension</tt> to size the field to
+	 */
+	public SizedPasswordField(final int columns, final Dimension dim) {
+		super(columns);
+		setPreferredSize(dim);
+		setMaximumSize(dim);
+	}
+}
Index: com/limegroup/gnutella/gui/options/panes/DaapPasswordPaneItem.java
===================================================================
RCS file: com/limegroup/gnutella/gui/options/panes/DaapPasswordPaneItem.java
diff -N com/limegroup/gnutella/gui/options/panes/DaapPasswordPaneItem.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ com/limegroup/gnutella/gui/options/panes/DaapPasswordPaneItem.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,117 @@
+package com.limegroup.gnutella.gui.options.panes;
+
+import java.io.IOException;
+
+import javax.swing.JCheckBox;
+import javax.swing.JTextField;
+import com.limegroup.gnutella.gui.SizedPasswordField;
+
+import com.limegroup.gnutella.gui.LabeledComponent;
+import com.limegroup.gnutella.settings.DaapSettings;
+import com.limegroup.gnutella.gui.DaapManager;
+
+public final class DaapPasswordPaneItem extends AbstractPaneItem {
+
+    
+    private final String CHECK_BOX_LABEL = 
+            "OPTIONS_ITUNES_DAAP_PASSWORD_CHECKBOX_LABEL";
+
+    private final String TEXTFIELD_BOX_LABEL = 
+            "OPTIONS_ITUNES_DAAP_PASSWORD_TEXTFIELD_LABEL";
+
+    /**
+     * Constant for the check box that specifies whether or not downloads 
+     * should be automatically cleared.
+     */
+    private final JCheckBox CHECK_BOX = new JCheckBox();
+
+    private final JTextField TEXT_FIELD = new SizedPasswordField();
+
+    /**
+     * The constructor constructs all of the elements of this 
+     * <tt>AbstractPaneItem</tt>.
+     *
+     * @param key the key for this <tt>AbstractPaneItem</tt> that the
+     *            superclass uses to generate locale-specific keys
+     */
+    public DaapPasswordPaneItem(final String key) {
+            super(key);
+            LabeledComponent comp = new LabeledComponent(CHECK_BOX_LABEL,
+                                         CHECK_BOX,
+                                         LabeledComponent.LEFT_GLUE);
+            add(comp.getComponent());
+
+            comp = new LabeledComponent(TEXTFIELD_BOX_LABEL,
+                                         TEXT_FIELD,
+                                         LabeledComponent.RIGHT_GLUE);
+
+            add(comp.getComponent());
+    }
+
+    /**
+     * Defines the abstract method in <tt>AbstractPaneItem</tt>.<p>
+     *
+     * Sets the options for the fields in this <tt>PaneItem</tt> when the 
+     * window is shown.
+     */
+    public void initOptions() {
+        CHECK_BOX.setSelected(DaapSettings.DAAP_REQUIRES_PASSWORD.getValue());
+
+        if (DaapSettings.DAAP_REQUIRES_PASSWORD.getValue())
+            TEXT_FIELD.setText(DaapSettings.DAAP_PASSWORD.getValue());
+    }
+
+    /**
+     * Defines the abstract method in <tt>AbstractPaneItem</tt>.<p>
+     *
+     * Applies the options currently set in this window, displaying an
+     * error message to the user if a setting could not be applied.
+     *
+     * @throws IOException if the options could not be applied for some reason
+     */
+    public boolean applyOptions() throws IOException {
+
+        final boolean prevRequiresPassword = DaapSettings.DAAP_REQUIRES_PASSWORD.getValue();
+        final String prevPassword = DaapSettings.DAAP_PASSWORD.getValue();
+        
+        final boolean requiresPassword = CHECK_BOX.isSelected();
+        final String password = TEXT_FIELD.getText().trim();
+        
+        if (password.equals("") && requiresPassword) { 
+            throw new IOException(); 
+        }
+
+        if ( ! password.equals(prevPassword))
+            DaapSettings.DAAP_PASSWORD.setValue(password);
+
+        if (requiresPassword != prevRequiresPassword || 
+                (requiresPassword && !password.equals(prevPassword))) {
+
+            DaapSettings.DAAP_REQUIRES_PASSWORD.setValue(requiresPassword);
+
+            try {
+
+                // A password is required now or password has changed, 
+                // disconnect all users...
+                if (requiresPassword) { 
+                    DaapManager.instance().disconnectAll();
+                }
+                
+                DaapManager.instance().updateService();
+
+            } catch (IOException err) {
+
+                DaapSettings.DAAP_REQUIRES_PASSWORD.setValue(prevRequiresPassword);
+                DaapSettings.DAAP_PASSWORD.setValue(prevPassword);
+
+                DaapManager.instance().stop();
+
+                initOptions();
+
+                throw err;
+            }
+        }
+
+        return false;
+    }
+}
Index: com/limegroup/gnutella/gui/options/panes/DaapSupportPaneItem.java
===================================================================
RCS file: com/limegroup/gnutella/gui/options/panes/DaapSupportPaneItem.java
diff -N com/limegroup/gnutella/gui/options/panes/DaapSupportPaneItem.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ com/limegroup/gnutella/gui/options/panes/DaapSupportPaneItem.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,143 @@
+package com.limegroup.gnutella.gui.options.panes;
+
+import java.io.IOException;
+
+import javax.swing.JCheckBox;
+import javax.swing.JTextField;
+import javax.swing.JRadioButton;
+import javax.swing.ButtonGroup;
+import com.limegroup.gnutella.gui.SizedTextField;
+
+import com.limegroup.gnutella.gui.LabeledComponent;
+import com.limegroup.gnutella.settings.DaapSettings;
+import com.limegroup.gnutella.gui.DaapManager;
+
+public final class DaapSupportPaneItem extends AbstractPaneItem {
+
+    
+    private final String DAAP_ENABLED_LABEL = 
+            "OPTIONS_ITUNES_DAAP_SUPPORT_DAAP_ENABLED_LABEL";
+
+    private final String USE_BIO_LABEL =
+            "OPTIONS_ITUNES_DAAP_SUPPORT_USE_BIO_LABEL";
+    
+    private final String USE_NIO_LABEL =
+            "OPTIONS_ITUNES_DAAP_SUPPORT_USE_NIO_LABEL";
+    
+    private final String SERVICE_NAME_LABEL = 
+            "OPTIONS_ITUNES_DAAP_SUPPORT_SERVICE_NAME_LABEL";
+
+
+    private final JCheckBox DAAP_ENABLED = new JCheckBox();
+
+    private final JRadioButton USE_BIO = new JRadioButton();
+    private final JRadioButton USE_NIO = new JRadioButton();
+
+    private final JTextField SERVICE_NAME = new SizedTextField();
+
+    /**
+     * The constructor constructs all of the elements of this 
+     * <tt>AbstractPaneItem</tt>.
+     *
+     * @param key the key for this <tt>AbstractPaneItem</tt> that the
+     *            superclass uses to generate locale-specific keys
+     */
+    public DaapSupportPaneItem(final String key) {
+        super(key);
+        
+        LabeledComponent comp = new LabeledComponent(DAAP_ENABLED_LABEL, DAAP_ENABLED,
+            LabeledComponent.LEFT_GLUE);
+        add(comp.getComponent());
+
+        ButtonGroup group = new ButtonGroup();
+        group.add(USE_BIO);
+        group.add(USE_NIO);
+        
+        comp = new LabeledComponent(USE_BIO_LABEL, USE_BIO,
+            LabeledComponent.LEFT_GLUE);
+        add(comp.getComponent());
+        
+        comp = new LabeledComponent(USE_NIO_LABEL, USE_NIO,
+            LabeledComponent.LEFT_GLUE);
+        add(comp.getComponent());
+        
+        comp = new LabeledComponent(SERVICE_NAME_LABEL, SERVICE_NAME,
+            LabeledComponent.RIGHT_GLUE);
+        
+        add(comp.getComponent());
+    }
+    
+    /**
+     * Defines the abstract method in <tt>AbstractPaneItem</tt>.<p>
+     *
+     * Sets the options for the fields in this <tt>PaneItem</tt> when the 
+     * window is shown.
+     */
+    public void initOptions() {
+        DAAP_ENABLED.setSelected(DaapSettings.DAAP_ENABLED.getValue() && 
+                    DaapManager.instance().isServerRunning());
+        
+        USE_NIO.setSelected(DaapSettings.DAAP_USE_NIO.getValue());
+        USE_BIO.setSelected(!USE_NIO.isSelected());
+        
+        SERVICE_NAME.setText(DaapSettings.DAAP_SERVICE_NAME.getValue());
+    }
+    
+    /**
+     * Defines the abstract method in <tt>AbstractPaneItem</tt>.<p>
+     *
+     * Applies the options currently set in this window, displaying an
+     * error message to the user if a setting could not be applied.
+     *
+     * @throws IOException if the options could not be applied for some reason
+     */
+    public boolean applyOptions() throws IOException {
+
+        final boolean prevEnabled = DaapSettings.DAAP_ENABLED.getValue();
+        final boolean prevUseNIO = DaapSettings.DAAP_USE_NIO.getValue();
+        final String prevServiceName = DaapSettings.DAAP_SERVICE_NAME.getValue();
+
+        String serviceName = SERVICE_NAME.getText().trim();
+
+        if (serviceName.length()==0 && DAAP_ENABLED.isSelected()) { 
+            throw new IOException(); 
+        }
+
+        DaapSettings.DAAP_ENABLED.setValue(DAAP_ENABLED.isSelected());
+        DaapSettings.DAAP_USE_NIO.setValue(USE_NIO.isSelected());
+        DaapSettings.DAAP_SERVICE_NAME.setValue(serviceName);
+        DaapSettings.DAAP_LIBRARY_NAME.setValue(serviceName);
+
+        try {
+            
+            if (DAAP_ENABLED.isSelected()) {
+                
+                if (!prevEnabled || USE_NIO.isSelected() != prevUseNIO) {
+                    DaapManager.instance().restart();
+                   
+                } else if (!serviceName.equals(prevServiceName)) {
+                    DaapManager.instance().updateService();
+                }
+                    
+            } else if (prevEnabled) {
+                
+                DaapManager.instance().stop();
+            }
+
+        } catch (IOException err) {
+
+            DaapSettings.DAAP_ENABLED.setValue(prevEnabled);
+            DaapSettings.DAAP_USE_NIO.setValue(prevUseNIO);
+            DaapSettings.DAAP_SERVICE_NAME.setValue(prevServiceName);
+            DaapSettings.DAAP_LIBRARY_NAME.setValue(prevServiceName);
+
+            DaapManager.instance().stop();
+
+            initOptions();
+
+            throw err;
+        }
+
+        return false;
+    }
+}
